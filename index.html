<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtracking Maze Explorer</title>
    <style>
        /* CSS Variables for consistent theming */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --accent-color: #2f8d46; /* GeeksforGeeks Green */
            --wall-color: #333333;
            --path-color: #ffffff;
            --visited-color: #a6d8b3; /* Light green for visited cells */
            --dead-end-color: #e74c3c; /* Distinct red for dead ends/backtracked cells */
            --solution-color: #58c072; /* Brighter green for solution path */
            --visiting-outline: #ffdd57; /* Yellow for current exploring cell */
            --start-end-fill: #2f8d46; /* Darker green for start/end markers */
            --border-color: #cccccc;
            --monospace-font: 'SF Mono', 'Consolas', 'Menlo', monospace;
        }

        /* Minimalist Reset & Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden; /* Prevent scrolling */
            font-family: var(--monospace-font);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Main Content Area */
        main {
            flex-grow: 1; /* Allow main to take available vertical space */
            width: 100%;
            max-width: 95vw; /* Limit max width for larger screens */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
            gap: 2vh; /* Space between elements */
            padding: 2vh 0; /* Vertical padding */
        }

        /* Status Display at the top */
        #status-display {
            width: 80%; /* Match width of controls-feedback-panel */
            max-width: 800px;
            padding: 1.5vh 2vw;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: #fdfdfd;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
            text-align: center; /* Center text within this box */
            min-height: 4.5vh; /* Ensure consistent height */
            display: flex;
            align-items: center; /* Vertically center text */
            justify-content: center; /* Horizontally center text */
            margin-bottom: 1vh; /* Space between status and maze */
            font-size: clamp(0.9rem, 2vh, 1.3rem); /* Slightly larger font for readability */
            font-weight: bold;
            color: var(--text-color);
        }
        @media (max-width: 768px) {
            #status-display {
                width: 95vw;
                padding: 1.5vh 3vw;
            }
        }


        /* Visualization Panel (Grid Container) */
        #visualization-panel {
            flex-shrink: 0; /* Prevent shrinking */
            display: grid;
            border: 1px solid var(--border-color);
            background-color: #f9f9f9;
            /* Max width/height based on aspect ratio to keep cells square */
            max-width: 70vw;
            max-height: 60vh; /* Adjusted height to accommodate status display */
            aspect-ratio: 1.76 / 1; /* (COLS / ROWS) from JS */
        }
        @media (max-width: 768px) {
            #visualization-panel {
                width: 95vw; /* Wider on small screens */
                height: 45vh; /* Adjust height */
            }
        }


        /* Individual Grid Cells */
        .cell {
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            border: 1px solid #eee; /* Light border for grid lines */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(0.6rem, 1.5vh, 1rem); /* Responsive font size for S/E */
            font-weight: bold;
            transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            user-select: none; /* Prevent text selection */
        }

        /* Cell States */
        .cell.wall {
            background-color: var(--wall-color);
            border-color: var(--wall-color);
        }
        .cell.start, .cell.end {
            background-color: var(--start-end-fill);
            color: white;
            border-color: var(--start-end-fill);
        }
        .cell.visited {
            background-color: var(--visited-color);
            border-color: #95c7a2;
        }
        .cell.visiting {
            box-shadow: inset 0 0 0 3px var(--visiting-outline); /* Outline for current cell */
            z-index: 2; /* Bring current cell to front for outline visibility */
        }
        .cell.dead-end {
            background-color: var(--dead-end-color);
            border-color: var(--dead-end-color); /* Use the distinct red for border too */
        }
        .cell.solution {
            background-color: var(--solution-color);
            border-color: #4db166;
            z-index: 1; /* Ensure solution path is above visited/dead-end */
        }

        /* Controls and Feedback Panel */
        #controls-feedback-panel {
            flex-shrink: 0;
            width: 80%; /* Adjusted width */
            max-width: 800px; /* Increased max width to accommodate buttons on one line */
            display: flex;
            flex-direction: row; /* Always row */
            align-items: center;
            justify-content: center; /* Center controls */
            padding: 2vh 2vw;
            border: 1px solid var(--border-color);
            border-radius: 8px; /* Slightly more rounded corners */
            background-color: #fdfdfd;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05); /* Subtle shadow */
            gap: 2vw; /* Space between buttons */
        }

        .controls {
            display: flex;
            gap: 1.5vw; /* Space between buttons */
            white-space: nowrap; /* Keep all buttons on a single line */
            overflow-x: auto; /* Allow horizontal scrolling if buttons exceed panel width */
            padding-bottom: 5px; /* Add some padding for scrollbar if it appears */
        }
        .controls::-webkit-scrollbar {
            height: 8px;
        }
        .controls::-webkit-scrollbar-thumb {
            background-color: var(--accent-color);
            border-radius: 4px;
        }
        .controls::-webkit-scrollbar-track {
            background-color: #f0f0f0;
        }
        /* Make the controls take full width on smaller screens, and center its content */
        @media (max-width: 768px) {
            #controls-feedback-panel {
                flex-direction: column; /* Stack controls and feedback vertically */
                align-items: stretch; /* Stretch items to full width */
                gap: 1.5vh;
                padding: 1.5vh 3vw;
                width: 95vw;
            }
            .controls {
                width: 100%;
                gap: 1.5vh; /* Adjust gap for vertical stacking */
                justify-content: space-around; /* Distribute buttons evenly */
            }
            .controls button {
                flex-grow: 1; /* Allow buttons to grow */
                min-width: 45%; /* Ensure at least two buttons per row */
            }
        }

        /* Button Styling */
        button {
            padding: 1.5vh 2vw;
            font-family: var(--monospace-font);
            font-size: clamp(0.7rem, 1.6vh, 1rem); /* Responsive font size */
            font-weight: bold;
            border: 2px solid var(--accent-color);
            background-color: var(--bg-color);
            color: var(--accent-color);
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 6px; /* Slightly more rounded buttons */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Button shadow */
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }

        button:hover:not(:disabled) {
            background-color: var(--accent-color);
            color: var(--bg-color);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* Larger shadow on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }
        
        button:disabled {
            border-color: #ccc;
            color: #ccc;
            background-color: #f0f0f0;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        .primary-action {
             background-color: var(--accent-color);
             color: var(--bg-color);
             border-color: var(--accent-color);
        }
        
.primary-action:hover:not(:disabled) {
    background-color: #267a3c; /* Darker green on hover */
    border-color: #267a3c;
}
    </style>
</head>
<body>

    <main>
        <div id="status-display">
            <p id="feedback-text"></p>
        </div>
        <div id="visualization-panel"></div>
        <div id="controls-feedback-panel">
            <div class="controls">
                <button id="randomize-btn">Randomize</button>
                <button id="next-step-btn">Next Step</button>
                <button id="auto-run-btn" class="primary-action">Auto-Run</button>
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            const COLS = 37; // Number of columns in the maze grid
            const ROWS = 21; // Number of rows in the maze grid
            const START_POS = { r: 1, c: 1 }; // Starting position (row, column)
            const END_POS = { r: ROWS - 2, c: COLS - 2 }; // Ending position (row, column)
            const AUTO_RUN_DELAY = 50; // Milliseconds delay for auto-run animation

            // --- DOM ELEMENTS ---
            const visualizationPanel = document.getElementById('visualization-panel');
            const feedbackText = document.getElementById('feedback-text');
            const randomizeBtn = document.getElementById('randomize-btn');
            const nextStepBtn = document.getElementById('next-step-btn');
            const autoRunBtn = document.getElementById('auto-run-btn');

            // --- GLOBAL STATE VARIABLES ---
            let mazeGrid = []; // 2D array representing the maze (0: path, 1: wall)
            let domGrid = []; // 2D array of DOM elements (cells)
            let pathfindingSteps = []; // Stores the sequence of algorithm steps for visualization
            let currentStepIndex = -1; // Current index in pathfindingSteps
            let autoRunInterval = null; // Interval ID for auto-run mode
            let isFinished = false; // Flag to indicate if the algorithm has finished (solved or failed)

            // --- INITIALIZATION ---

            /**
             * Initializes the application: sets up the grid, generates initial maze,
             * prepares the solver, and attaches event listeners.
             */
            function init() {
                setupGrid();
                // Ensure the "Generating..." message appears first
                feedbackText.textContent = "Generating your first random maze..."; 
                
                // A tiny delay to allow the "Generating..." message to render,
                // otherwise it might be too fast to notice.
                setTimeout(() => {
                    randomizeMaze(); // This call will now populate the mazeGrid and domGrid
                    // After randomizeMaze and its internal resetVisualization, set final message
                    feedbackText.textContent = "A random maze is ready! Click 'Next Step' or 'Auto-Run'.";
                }, 10); // Small delay, just enough for browser to paint the text
                
                addEventListeners(); // Add listeners last to ensure elements are ready
            }

            /**
             * Sets up the HTML grid elements and initializes the internal maze data structure.
             */
            function setupGrid() {
                visualizationPanel.innerHTML = ''; // Clear any existing cells
                // Set grid dimensions based on COLS and ROWS
                visualizationPanel.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
                visualizationPanel.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;
                
                mazeGrid = [];
                domGrid = [];

                for (let r = 0; r < ROWS; r++) {
                    const mazeRow = [];
                    const domRow = [];
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.r = r; // Store row in data attribute
                        cell.dataset.c = c; // Store column in data attribute
                        visualizationPanel.appendChild(cell);
                        mazeRow.push(1); // Initially all cells are walls (1)
                        domRow.push(cell);
                    }
                    mazeGrid.push(mazeRow);
                    domGrid.push(domRow);
                }
            }

            /**
             * Generates a random maze using a randomized Depth-First Search (DFS) algorithm.
             * This ensures a single, solvable path from start to end.
             */
            function randomizeMaze() {
                resetState(); // Clear previous state and visualization
                // During subsequent randomizations, provide feedback
                if (currentStepIndex === -1 && !isFinished) { // Check if it's not the initial load feedback
                   feedbackText.textContent = "Generating a new maze...";
                }
                
                // 1. Fill grid with walls (already done in setupGrid initially, but re-init here)
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        mazeGrid[r][c] = 1; // Mark all as walls
                    }
                }
                
                const stack = [];
                const startNode = { r: START_POS.r, c: START_POS.c };
                mazeGrid[startNode.r][startNode.c] = 0; // Mark start as path
                stack.push(startNode);
                
                // Directions for maze generation (move 2 steps at a time)
                const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];

                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    
                    // Shuffle directions to ensure randomness
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }

                    let moved = false;
                    for (const [dr, dc] of directions) {
                        const nr = current.r + dr; // New row
                        const nc = current.c + dc; // New column

                        // Check bounds and if the next cell is a wall
                        if (nr > 0 && nr < ROWS - 1 && nc > 0 && nc < COLS - 1 && mazeGrid[nr][nc] === 1) {
                            mazeGrid[nr][nc] = 0; // Carve path at the new cell
                            // Carve path in the wall cell between current and new cell
                            mazeGrid[current.r + dr / 2][current.c + dc / 2] = 0;
                            stack.push({ r: nr, c: nc }); // Push new cell to stack
                            moved = true;
                            break; // Move to the next cell
                        }
                    }

                    if (!moved) {
                        stack.pop(); // Backtrack if no unvisited neighbors
                    }
                }
                
                // Ensure start and end points are always accessible paths
                mazeGrid[START_POS.r][START_POS.c] = 0;
                mazeGrid[END_POS.r][END_POS.c] = 0;
                // Make sure the cell just before the end is also a path
                mazeGrid[END_POS.r][END_POS.c - 1] = 0; 

                // After maze generation, solve it to record steps
                solveAndPrepare();
            }

            /**
             * Pre-calculates the backtracking path and stores each step for visualization.
             * This function uses a standard recursive DFS for the solver.
             */
            function solveAndPrepare() {
                pathfindingSteps = []; // Reset steps
                const visited = new Set(); // Keep track of visited cells using a Set for faster lookups
                const path = []; // Current path being explored
                let solutionFound = false;

                /**
                 * Recursive helper function for the backtracking maze solver.
                 * @param {number} r Current row.
                 * @param {number} c Current column.
                 * @returns {boolean} True if a path to the end is found from (r, c), false otherwise.
                 */
                function solveRecursive(r, c) {
                    // Base Cases for stopping exploration:
                    // 1. Out of bounds
                    // 2. Is a wall
                    // 3. Already visited (to prevent infinite loops)
                    if (r < 0 || r >= ROWS || c < 0 || c >= COLS || mazeGrid[r][c] === 1 || visited.has(`${r},${c}`)) {
                        if (mazeGrid[r] && mazeGrid[r][c] === 0 && visited.has(`${r},${c}`)) {
                            // Only add dead-check for valid path cells that were already visited
                            pathfindingSteps.push({ type: 'dead-check', r, c, message: `Path at (${c}, ${r}) already visited or invalid.` });
                        }
                        return false;
                    }
                    
                    // Mark current cell as visited and add to current path
                    visited.add(`${r},${c}`);
                    path.push({ r, c });
                    // Record this 'visit' step for visualization
                    pathfindingSteps.push({ type: 'visit', r, c, path: [...path], message: `Exploring path at (${c}, ${r})...` });

                    // Check if current cell is the end destination
                    if (r === END_POS.r && c === END_POS.c) {
                        pathfindingSteps.push({ type: 'solution', path: [...path], message: `Solution found!` });
                        solutionFound = true;
                        return true; // Solution found!
                    }

                    // Define possible directions (Right, Down, Left, Up)
                    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; 
                    // Shuffle directions for randomized solving (if path is found)
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }

                    // Explore neighbors
                    for (const [dr, dc] of directions) {
                        if (solveRecursive(r + dr, c + dc)) {
                            return true; // If recursive call finds solution, propagate true
                        }
                    }
                    
                    // If no direction leads to a solution, backtrack:
                    path.pop(); // Remove current cell from path (it's a dead end)
                    // Record 'backtrack' step for visualization
                    pathfindingSteps.push({ type: 'backtrack', r, c, path: [...path], message: `Dead end at (${c}, ${r}). Backtracking...` });
                    return false; // No solution from this path
                }

                // Start the recursive solving from the START_POS
                solveRecursive(START_POS.r, START_POS.c);
                
                // If after all exploration, no solution was found
                if (!solutionFound) {
                    pathfindingSteps.push({ type: 'no-solution', message: `No solution exists for this maze.` });
                }
                
                // After preparing all steps, reset the visual to initial maze state
                resetVisualization();
            }

            /**
             * Resets the visual state of the grid to its initial maze structure
             * without clearing the generated maze or solver steps.
             */
            function resetVisualization() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = domGrid[r][c];
                        cell.className = 'cell'; // Reset all classes to just 'cell'
                        cell.textContent = ''; // Clear text content
                        if (mazeGrid[r][c] === 1) {
                            cell.classList.add('wall'); // Apply wall class if it's a wall
                        }
                    }
                }
                // Reapply start and end markers
                domGrid[START_POS.r][START_POS.c].classList.add('start');
                domGrid[START_POS.r][START_POS.c].textContent = 'S';
                domGrid[END_POS.r][END_POS.c].classList.add('end');
                domGrid[END_POS.r][END_POS.c].textContent = 'E';
                
                currentStepIndex = -1; // Reset step index
                isFinished = false; // Reset finished flag
                updateButtonStates(); // Update button states
            }
            
            /**
             * Fully resets the application's state, clearing all dynamic data and intervals.
             */
            function resetState() {
                if (autoRunInterval) {
                    clearInterval(autoRunInterval);
                    autoRunInterval = null;
                }
                pathfindingSteps = [];
                currentStepIndex = -1;
                isFinished = false;
            }

            /**
             * Renders a single step of the algorithm based on `currentStepIndex`.
             * Updates cell colors and the feedback text.
             */
            function renderStep() {
                if (currentStepIndex < 0 || currentStepIndex >= pathfindingSteps.length) return;

                const step = pathfindingSteps[currentStepIndex];
                feedbackText.textContent = step.message;

                // Clear dynamic styles that should NOT persist (i.e., temporary highlights)
                // IMPORTANT: Do NOT remove 'dead-end' here, as it should persist
                document.querySelectorAll('.visiting, .visited, .solution').forEach(el => {
                    el.classList.remove('visiting', 'visited', 'solution');
                });
                
                // Apply 'visited' class to cells that are part of the current path,
                // ensuring they don't overwrite a 'dead-end' status.
                if (step.path) {
                    step.path.forEach(pos => {
                        const cell = domGrid[pos.r][pos.c];
                        if (!(pos.r === START_POS.r && pos.c === START_POS.c) && 
                            !(pos.r === END_POS.r && pos.c === END_POS.c) &&
                            !cell.classList.contains('dead-end')) { 
                             cell.classList.add('visited');
                        }
                    });
                }
                
                // Apply specific styles for the current action
                switch(step.type) {
                    case 'visit':
                        domGrid[step.r][step.c].classList.add('visiting');
                        break;
                    case 'backtrack':
                        // When backtracking, the cell being left becomes a dead-end
                        domGrid[step.r][step.c].classList.add('dead-end');
                        // Ensure it's no longer marked as 'visiting' or 'visited' if it was
                        domGrid[step.r][step.c].classList.remove('visiting', 'visited');
                        break;
                    case 'solution':
                        // When solution is found, overwrite all previous path states with 'solution'
                        step.path.forEach(pos => {
                            const cell = domGrid[pos.r][pos.c];
                            cell.classList.add('solution');
                            cell.classList.remove('dead-end', 'visited', 'visiting'); 
                        });
                        isFinished = true;
                        break;
                    case 'no-solution':
                        isFinished = true;
                        break;
                    case 'dead-check':
                        // No specific visual change for dead-check, message updates
                        break;
                }
            }
            
            /**
             * Advances the visualization to the next step in the `pathfindingSteps` array.
             * If the end is reached or no solution is found, it updates the UI state.
             */
            function nextStep() {
                if (isFinished) {
                    if (autoRunInterval) toggleAutoRun();
                    return;
                }
                
                if (currentStepIndex < pathfindingSteps.length - 1) {
                    currentStepIndex++;
                    renderStep();
                } else {
                    isFinished = true;
                    if (autoRunInterval) toggleAutoRun();
                }
                updateButtonStates();
            }

            /**
             * Toggles the auto-run mode (starts or pauses the automatic stepping).
             */
            function toggleAutoRun() {
                if (autoRunInterval) {
                    clearInterval(autoRunInterval);
                    autoRunInterval = null;
                    autoRunBtn.textContent = 'Auto-Run';
                } else {
                    if (isFinished) return;

                    autoRunBtn.textContent = 'Pause';
                    autoRunInterval = setInterval(() => {
                        nextStep();
                        if (isFinished) {
                           toggleAutoRun(); 
                        }
                    }, AUTO_RUN_DELAY);
                }
                updateButtonStates();
            }

            /**
             * Updates the enabled/disabled state of control buttons based on
             * the current algorithm state (running, paused, finished).
             */
            function updateButtonStates() {
                const isRunning = autoRunInterval !== null;
                
                randomizeBtn.disabled = isRunning;
                nextStepBtn.disabled = isRunning || isFinished;
                autoRunBtn.disabled = isFinished;
            }

            /**
             * Attaches all necessary event listeners to the control buttons
             * and window resize.
             */
            function addEventListeners() {
                randomizeBtn.addEventListener('click', randomizeMaze);
                nextStepBtn.addEventListener('click', nextStep);
                autoRunBtn.addEventListener('click', toggleAutoRun);
                
                window.addEventListener('resize', () => {
                    setupGrid();
                    // Preserve the current maze structure
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (mazeGrid[r][c] === 1) {
                                domGrid[r][c].classList.add('wall');
                            } else {
                                domGrid[r][c].classList.remove('wall');
                            }
                        }
                    }
                    // Re-render the current step's visualization state
                    // We need to re-apply *all* previous steps to maintain dead-end highlights
                    resetVisualization(); // Resets to initial clean maze
                    for(let i = 0; i <= currentStepIndex; i++) {
                        renderStepFromData(pathfindingSteps[i]);
                    }
                    // If algorithm is finished, set appropriate message
                    if (isFinished) {
                        feedbackText.textContent = pathfindingSteps[pathfindingSteps.length - 1]?.message || "Algorithm finished.";
                    } else if (currentStepIndex > -1) {
                         feedbackText.textContent = pathfindingSteps[currentStepIndex]?.message;
                    } else {
                        feedbackText.textContent = "A random maze is ready! Click 'Next Step' or 'Auto-Run'.";
                    }
                    updateButtonStates(); // Re-enable/disable buttons as per state
                });
            }

            /**
             * Helper function to re-apply classes for a given step data,
             * used on resize to rebuild the visual state without re-running animation.
             * @param {object} step The step data from pathfindingSteps.
             */
            function renderStepFromData(step) {
                // This function should add classes without clearing others,
                // as it's rebuilding a historical state.
                if (step.path) {
                    step.path.forEach(pos => {
                        const cell = domGrid[pos.r][pos.c];
                        if (!(pos.r === START_POS.r && pos.c === START_POS.c) && 
                            !(pos.r === END_POS.r && pos.c === END_POS.c) &&
                            !cell.classList.contains('dead-end')) { // Don't overwrite existing dead-end
                             cell.classList.add('visited');
                        }
                    });
                }
                
                switch(step.type) {
                    case 'visit':
                        domGrid[step.r][step.c].classList.add('visiting');
                        break;
                    case 'backtrack':
                        domGrid[step.r][step.c].classList.add('dead-end');
                        domGrid[step.r][step.c].classList.remove('visiting', 'visited'); // Ensure no other path classes
                        break;
                    case 'solution':
                        step.path.forEach(pos => {
                            const cell = domGrid[pos.r][pos.c].classList.add('solution');
                            cell.classList.remove('dead-end', 'visited', 'visiting'); // Solution overrides all
                        });
                        break;
                }
            }


            // --- KICK OFF THE APPLICATION ---
            init();
        });
    </script>
</body>
</html>
