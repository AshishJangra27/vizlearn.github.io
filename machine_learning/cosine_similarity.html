import React, { useRef, useEffect, useState, useCallback } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { DragControls } from 'three/examples/jsm/controls/DragControls.js';

// Main App component
const App = () => {
  // State for Vector A components (relative to current origin)
  const [vectorA, setVectorA] = useState({ x: 1, y: 1, z: 0 });
  // State for Vector B components (relative to current origin)
  const [vectorB, setVectorB] = useState({ x: -1, y: 1, z: 0 });
  // State for the origin position of the coordinate system
  const [originPosition, setOriginPosition] = useState({ x: 0, y: 0, z: 0 });

  // State for calculated values
  const [angleDegrees, setAngleDegrees] = useState(0);
  const [cosineSimilarity, setCosineSimilarity] = useState(0);


  // Ref for the 3D canvas container
  const mountRef = useRef(null);
  // Refs for Three.js objects
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const controlsRef = useRef(null); // OrbitControls
  const dragControlsRef = useRef(null); // DragControls
  const arrowA_Ref = useRef(null);
  const arrowB_Ref = useRef(null);
  const sphereA_Ref = useRef(null); // Draggable sphere for Vector A endpoint
  const sphereB_Ref = useRef(null); // Draggable sphere for Vector B endpoint
  const originSphere_Ref = useRef(null); // Draggable sphere for the origin
  const axesHelperRef = useRef(null);
  const gridHelperRef = useRef(null);
  const angleCurve_Ref = useRef(null); // Ref for the angle curve

  // Function to calculate the angle and cosine similarity between vectors
  const calculateMetrics = useCallback(() => {
    const vecA = new THREE.Vector3(vectorA.x, vectorA.y, vectorA.z);
    const vecB = new THREE.Vector3(vectorB.x, vectorB.y, vectorB.z);

    const magnitudeA = vecA.length();
    const magnitudeB = vecB.length();

    if (magnitudeA === 0 || magnitudeB === 0) {
      setAngleDegrees(0);
      setCosineSimilarity(0);
      return;
    }

    const cosSim = vecA.dot(vecB) / (magnitudeA * magnitudeB);
    setCosineSimilarity(cosSim);
    
    const angleRad = Math.acos(Math.min(1, Math.max(-1, cosSim)));
    setAngleDegrees(THREE.MathUtils.radToDeg(angleRad));
  }, [vectorA, vectorB]);

  // Effect to initialize the 3D scene and controls
  useEffect(() => {
    const currentMount = mountRef.current;
    if (!currentMount) return;

    const scene = new THREE.Scene();
    sceneRef.current = scene;
    scene.background = new THREE.Color(0x1a202c);

    const camera = new THREE.PerspectiveCamera(75, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1000);
    camera.position.set(2.5, 2.5, 2.5);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
    currentMount.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controlsRef.current = controls;

    const axesHelper = new THREE.AxesHelper(1);
    scene.add(axesHelper);
    axesHelperRef.current = axesHelper;

    const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x444444);
    scene.add(gridHelper);
    gridHelperRef.current = gridHelper;

    const sphereMaterialDefault = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 });
    const sphereMaterialHoverA = new THREE.MeshBasicMaterial({ color: 0x34d399, transparent: true, opacity: 0.7 });
    const sphereMaterialHoverB = new THREE.MeshBasicMaterial({ color: 0xf472b6, transparent: true, opacity: 0.7 });
    const sphereMaterialHoverOrigin = new THREE.MeshBasicMaterial({ color: 0x22d3ee, transparent: true, opacity: 0.7 });
    const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const originSphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);

    const vecA_initial = new THREE.Vector3(vectorA.x, vectorA.y, vectorA.z);
    const origin = new THREE.Vector3(originPosition.x, originPosition.y, originPosition.z);
    const arrowA = new THREE.ArrowHelper(vecA_initial.clone().normalize(), origin, vecA_initial.length(), 0x34d399, 0.3, 0.15);
    scene.add(arrowA);
    arrowA_Ref.current = arrowA;

    const sphereA = new THREE.Mesh(sphereGeometry, sphereMaterialDefault);
    sphereA.position.copy(origin).add(vecA_initial);
    sphereA.userData.vectorType = 'A';
    scene.add(sphereA);
    sphereA_Ref.current = sphereA;

    const vecB_initial = new THREE.Vector3(vectorB.x, vectorB.y, vectorB.z);
    const arrowB = new THREE.ArrowHelper(vecB_initial.clone().normalize(), origin, vecB_initial.length(), 0xf472b6, 0.3, 0.15);
    scene.add(arrowB);
    arrowB_Ref.current = arrowB;

    const sphereB = new THREE.Mesh(sphereGeometry, sphereMaterialDefault);
    sphereB.position.copy(origin).add(vecB_initial);
    sphereB.userData.vectorType = 'B';
    scene.add(sphereB);
    sphereB_Ref.current = sphereB;

    const originSphere = new THREE.Mesh(originSphereGeometry, sphereMaterialDefault);
    originSphere.position.copy(origin);
    originSphere.userData.vectorType = 'Origin';
    scene.add(originSphere);
    originSphere_Ref.current = originSphere;

    const angleCurveMaterial = new THREE.LineBasicMaterial({ color: 0xfacc15 });
    const angleCurveGeometry = new THREE.BufferGeometry();
    const angleCurve = new THREE.Line(angleCurveGeometry, angleCurveMaterial);
    scene.add(angleCurve);
    angleCurve_Ref.current = angleCurve;

    const draggableObjects = [sphereA, sphereB, originSphere];
    const dragControls = new DragControls(draggableObjects, camera, renderer.domElement);
    dragControlsRef.current = dragControls;

    dragControls.addEventListener('dragstart', (event) => {
      controls.enabled = false;
      if (event.object.userData.vectorType === 'A') event.object.material = sphereMaterialHoverA;
      else if (event.object.userData.vectorType === 'B') event.object.material = sphereMaterialHoverB;
      else if (event.object.userData.vectorType === 'Origin') event.object.material = sphereMaterialHoverOrigin;
    });

    dragControls.addEventListener('drag', (event) => {
      const newPos = event.object.position;
      const currentOrigin = new THREE.Vector3(originPosition.x, originPosition.y, originPosition.z);
      if (event.object.userData.vectorType === 'A') {
        const newVectorA = newPos.clone().sub(currentOrigin);
        setVectorA({ x: newVectorA.x, y: newVectorA.y, z: newVectorA.z });
      } else if (event.object.userData.vectorType === 'B') {
        const newVectorB = newPos.clone().sub(currentOrigin);
        setVectorB({ x: newVectorB.x, y: newVectorB.y, z: newVectorB.z });
      } else if (event.object.userData.vectorType === 'Origin') {
        setOriginPosition({ x: newPos.x, y: newPos.y, z: newPos.z });
      }
    });

    dragControls.addEventListener('dragend', (event) => {
      controls.enabled = true;
      event.object.material = sphereMaterialDefault;
    });

    dragControls.addEventListener('hoveron', (event) => {
      if (dragControls.object) return;
      if (event.object.userData.vectorType === 'A') event.object.material = sphereMaterialHoverA;
      else if (event.object.userData.vectorType === 'B') event.object.material = sphereMaterialHoverB;
      else if (event.object.userData.vectorType === 'Origin') event.object.material = sphereMaterialHoverOrigin;
    });

    dragControls.addEventListener('hoveroff', (event) => {
      event.object.material = sphereMaterialDefault;
    });

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    const handleResize = () => {
      if (currentMount) {
        camera.aspect = currentMount.clientWidth / currentMount.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
      }
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (currentMount && renderer.domElement) {
        currentMount.removeChild(renderer.domElement);
      }
      dragControls.dispose();
      controls.dispose();
      renderer.dispose();
      scene.traverse((object) => {
        if (object.isMesh) {
          object.geometry.dispose();
          if (Array.isArray(object.material)) {
            object.material.forEach((material) => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Effect to update Three.js objects when state changes
  useEffect(() => {
    if (arrowA_Ref.current && arrowB_Ref.current && sphereA_Ref.current && sphereB_Ref.current && originSphere_Ref.current && axesHelperRef.current && gridHelperRef.current && angleCurve_Ref.current) {
      const currentOrigin = new THREE.Vector3(originPosition.x, originPosition.y, originPosition.z);
      const vecA = new THREE.Vector3(vectorA.x, vectorA.y, vectorA.z);
      const vecB = new THREE.Vector3(vectorB.x, vectorB.y, vectorB.z);

      axesHelperRef.current.position.copy(currentOrigin);
      gridHelperRef.current.position.copy(currentOrigin);
      originSphere_Ref.current.position.copy(currentOrigin);

      arrowA_Ref.current.position.copy(currentOrigin);
      const lengthA = vecA.length();
      if (lengthA > 0.01) {
        arrowA_Ref.current.setDirection(vecA.clone().normalize());
        arrowA_Ref.current.setLength(lengthA, 0.3, 0.15);
        arrowA_Ref.current.visible = true;
      } else {
        arrowA_Ref.current.visible = false;
      }
      sphereA_Ref.current.position.copy(currentOrigin).add(vecA);
      sphereA_Ref.current.visible = true;

      arrowB_Ref.current.position.copy(currentOrigin);
      const lengthB = vecB.length();
      if (lengthB > 0.01) {
        arrowB_Ref.current.setDirection(vecB.clone().normalize());
        arrowB_Ref.current.setLength(lengthB, 0.3, 0.15);
        arrowB_Ref.current.visible = true;
      } else {
        arrowB_Ref.current.visible = false;
      }
      sphereB_Ref.current.position.copy(currentOrigin).add(vecB);
      sphereB_Ref.current.visible = true;

      const angle = vecA.angleTo(vecB);
      const curveRadius = 0.4;
      if (angle > 0.01 && lengthA > 0.01 && lengthB > 0.01) {
        const vecA_norm = vecA.clone().normalize();
        const axis = new THREE.Vector3().crossVectors(vecA_norm, vecB.clone().normalize()).normalize();
        if (axis.lengthSq() > 0.1) {
            const points = [];
            const numSegments = 32;
            const quaternion = new THREE.Quaternion();
            for (let i = 0; i <= numSegments; i++) {
                const t = i / numSegments;
                quaternion.setFromAxisAngle(axis, angle * t);
                const point = vecA_norm.clone().applyQuaternion(quaternion).multiplyScalar(curveRadius).add(currentOrigin);
                points.push(point);
            }
            angleCurve_Ref.current.geometry.setFromPoints(points);
            angleCurve_Ref.current.visible = true;
        } else {
             angleCurve_Ref.current.visible = false;
        }
      } else {
        angleCurve_Ref.current.visible = false;
      }

      calculateMetrics();
    }
  }, [vectorA, vectorB, originPosition, calculateMetrics]);

  const handleVectorChange = (setter) => (e) => {
    const { name, value } = e.target;
    const parsedValue = value === '-' ? '-' : (parseFloat(value) || 0);
    setter((prev) => ({ ...prev, [name]: parsedValue }));
  };
  
  const handleBlur = (setter) => (e) => {
      const { name, value } = e.target;
      if (value === '' || value === '-') {
          setter((prev) => ({ ...prev, [name]: 0 }));
      }
  }

  return (
    <div className="h-screen bg-gray-900 text-gray-100 font-mono flex flex-col">
      {/* Header */}
      <div className="bg-gray-800 shadow-lg p-3 flex flex-col items-center space-y-3">
        <h1 className="text-xl font-bold text-blue-400">3D Vector Angle Calculator</h1>
        
        {/* Vector Inputs */}
        <div className="flex flex-col md:flex-row justify-center items-center gap-x-6 gap-y-2 w-full">
          <div className="flex items-center space-x-2">
            <label className="text-lg text-green-400 font-bold">A:</label>
            <input type="number" name="x" value={vectorA.x} onChange={handleVectorChange(setVectorA)} onBlur={handleBlur(setVectorA)} className="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500" />
            <input type="number" name="y" value={vectorA.y} onChange={handleVectorChange(setVectorA)} onBlur={handleBlur(setVectorA)} className="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500" />
            <input type="number" name="z" value={vectorA.z} onChange={handleVectorChange(setVectorA)} onBlur={handleBlur(setVectorA)} className="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500" />
          </div>
          <div className="flex items-center space-x-2">
            <label className="text-lg text-fuchsia-400 font-bold">B:</label>
            <input type="number" name="x" value={vectorB.x} onChange={handleVectorChange(setVectorB)} onBlur={handleBlur(setVectorB)} className="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-fuchsia-500" />
            <input type="number" name="y" value={vectorB.y} onChange={handleVectorChange(setVectorB)} onBlur={handleBlur(setVectorB)} className="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-fuchsia-500" />
            <input type="number" name="z" value={vectorB.z} onChange={handleVectorChange(setVectorB)} onBlur={handleBlur(setVectorB)} className="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-fuchsia-500" />
          </div>
        </div>
        
        <p className="text-xs text-gray-400 text-center w-full pt-2 border-t border-gray-700">
          Drag vector endpoints or the origin. Use mouse to orbit and zoom.
        </p>
      </div>

      {/* Main content area: 3D Visualization */}
      <div className="flex-grow bg-gray-800 overflow-hidden relative">
        <div ref={mountRef} className="w-full h-full"></div>
        <div className="absolute top-2 right-2 flex flex-col items-end gap-2 text-right">
            {/* Metrics Display */}
            <div className="bg-gray-900 bg-opacity-60 p-2 rounded-lg">
                <div className="text-xl text-yellow-300">
                  Angle: <span className="font-bold">{angleDegrees.toFixed(2)}Â°</span>
                </div>
                <div className="text-base text-cyan-300 mt-1">
                  Cosine Sim: <span className="font-bold">{cosineSimilarity.toFixed(4)}</span>
                </div>
            </div>

            {/* Vector Coordinates Display */}
            <div className="flex flex-col gap-2 text-sm bg-gray-900 bg-opacity-60 p-2 rounded-lg">
                <div className="text-green-400">A: ({vectorA.x.toFixed(2)}, {vectorA.y.toFixed(2)}, {vectorA.z.toFixed(2)})</div>
                <div className="text-fuchsia-400">B: ({vectorB.x.toFixed(2)}, {vectorB.y.toFixed(2)}, {vectorB.z.toFixed(2)})</div>
            </div>
        </div>
      </div>
    </div>
  );
};

export default App;
