<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Vector Angle Calculator (HTML & JS)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import maps for Three.js modules -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
      }
    }
    </script>
    <style>
        /* Custom font and ensuring the body/html take full height */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto+Mono&display=swap');
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden; /* Prevent scrolling on the main page */
        }
        /* Style number inputs to hide arrows */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <div id="app" class="h-screen flex flex-col">
        <!-- Header Section -->
        <header class="bg-gray-800 shadow-lg p-3 flex flex-col items-center space-y-3">
            <h1 class="text-xl font-bold text-blue-400">3D Vector Angle Calculator</h1>
            
            <!-- Vector Input Fields -->
            <div class="flex flex-col md:flex-row justify-center items-center gap-x-6 gap-y-2 w-full">
                <!-- Vector A -->
                <div class="flex items-center space-x-2">
                    <label class="text-lg text-green-400 font-bold">A:</label>
                    <input type="number" id="vecAx" class="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500" value="1">
                    <input type="number" id="vecAy" class="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500" value="1">
                    <input type="number" id="vecAz" class="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500" value="0">
                </div>
                <!-- Vector B -->
                <div class="flex items-center space-x-2">
                    <label class="text-lg text-fuchsia-400 font-bold">B:</label>
                    <input type="number" id="vecBx" class="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-fuchsia-500" value="-1">
                    <input type="number" id="vecBy" class="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-fuchsia-500" value="1">
                    <input type="number" id="vecBz" class="w-20 p-1 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-fuchsia-500" value="0">
                </div>
            </div>
            
            <p class="text-xs text-gray-400 text-center w-full pt-2 border-t border-gray-700">
              Drag vector endpoints or the origin. Use mouse to orbit and zoom.
            </p>
        </header>

        <!-- Main Content: 3D Visualization -->
        <main class="flex-grow bg-gray-800 overflow-hidden relative">
            <div id="canvas-container" class="w-full h-full"></div>
            
            <!-- Overlays for metrics and coordinates -->
            <div class="absolute top-2 right-2 flex flex-col items-end gap-2 text-right">
                <!-- Metrics Display -->
                <div class="bg-gray-900 bg-opacity-60 p-2 rounded-lg">
                    <div class="text-xl text-yellow-300">
                      Angle: <span id="angle-display" class="font-bold">0.00°</span>
                    </div>
                    <div class="text-base text-cyan-300 mt-1">
                      Cosine Sim: <span id="cosine-sim-display" class="font-bold">0.0000</span>
                    </div>
                </div>

                <!-- Vector Coordinates Display -->
                <div class="flex flex-col gap-2 text-sm bg-gray-900 bg-opacity-60 p-2 rounded-lg">
                    <div id="vecA-coords" class="text-green-400">A: (1.00, 1.00, 0.00)</div>
                    <div id="vecB-coords" class="text-fuchsia-400">B: (-1.00, 1.00, 0.00)</div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        // --- DOM Elements ---
        const canvasContainer = document.getElementById('canvas-container');
        // Inputs
        const vecAx_input = document.getElementById('vecAx');
        const vecAy_input = document.getElementById('vecAy');
        const vecAz_input = document.getElementById('vecAz');
        const vecBx_input = document.getElementById('vecBx');
        const vecBy_input = document.getElementById('vecBy');
        const vecBz_input = document.getElementById('vecBz');
        // Displays
        const angleDisplay = document.getElementById('angle-display');
        const cosineSimDisplay = document.getElementById('cosine-sim-display');
        const vecACoordsDisplay = document.getElementById('vecA-coords');
        const vecBCoordsDisplay = document.getElementById('vecB-coords');

        // --- Global State & Three.js Objects ---
        let scene, camera, renderer, orbitControls, dragControls;
        let arrowA, arrowB, sphereA, sphereB, originSphere, angleCurve;
        let draggableObjects = [];

        // State object to hold vector and metric values
        const state = {
            vectorA: new THREE.Vector3(1, 1, 0),
            vectorB: new THREE.Vector3(-1, 1, 0),
            origin: new THREE.Vector3(0, 0, 0),
            angleDegrees: 90,
            cosineSimilarity: 0
        };

        // --- Main Functions ---

        /**
         * Initializes the entire 3D scene, controls, and event listeners.
         */
        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(2.5, 2.5, 2.5);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);

            // 4. Controls Setup
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;

            // 5. Helpers
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x444444);
            scene.add(gridHelper);

            // 6. Materials and Geometries
            const sphereMaterialDefault = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 });
            const sphereMaterialHoverA = new THREE.MeshBasicMaterial({ color: 0x34d399, transparent: true, opacity: 0.7 });
            const sphereMaterialHoverB = new THREE.MeshBasicMaterial({ color: 0xf472b6, transparent: true, opacity: 0.7 });
            const sphereMaterialHoverOrigin = new THREE.MeshBasicMaterial({ color: 0x22d3ee, transparent: true, opacity: 0.7 });
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const originSphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            
            // 7. Create Scene Objects
            // Vector A
            arrowA = new THREE.ArrowHelper(state.vectorA.clone().normalize(), state.origin, state.vectorA.length(), 0x34d399, 0.3, 0.15);
            scene.add(arrowA);
            sphereA = new THREE.Mesh(sphereGeometry.clone(), sphereMaterialDefault.clone());
            sphereA.userData = { vectorType: 'A', material: sphereMaterialDefault, hoverMaterial: sphereMaterialHoverA };
            scene.add(sphereA);
            
            // Vector B
            arrowB = new THREE.ArrowHelper(state.vectorB.clone().normalize(), state.origin, state.vectorB.length(), 0xf472b6, 0.3, 0.15);
            scene.add(arrowB);
            sphereB = new THREE.Mesh(sphereGeometry.clone(), sphereMaterialDefault.clone());
            sphereB.userData = { vectorType: 'B', material: sphereMaterialDefault, hoverMaterial: sphereMaterialHoverB };
            scene.add(sphereB);

            // Origin
            originSphere = new THREE.Mesh(originSphereGeometry.clone(), sphereMaterialDefault.clone());
            originSphere.userData = { vectorType: 'Origin', material: sphereMaterialDefault, hoverMaterial: sphereMaterialHoverOrigin };
            scene.add(originSphere);

            // Angle Curve
            const angleCurveMaterial = new THREE.LineBasicMaterial({ color: 0xfacc15 });
            const angleCurveGeometry = new THREE.BufferGeometry();
            angleCurve = new THREE.Line(angleCurveGeometry, angleCurveMaterial);
            scene.add(angleCurve);

            draggableObjects = [sphereA, sphereB, originSphere];

            // 8. Drag Controls
            dragControls = new DragControls(draggableObjects, camera, renderer.domElement);
            setupDragControls();
            
            // 9. Initial Update & Animation
            updateAll();
            animate();

            // 10. Event Listeners
            setupEventListeners();
        }

        /**
         * The main animation loop.
         */
        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        /**
         * Updates all calculations, scene objects, and UI displays.
         */
        function updateAll() {
            calculateMetrics();
            updateSceneObjects();
            updateUI();
        }

        /**
         * Updates the position and properties of all Three.js objects based on the current state.
         */
        function updateSceneObjects() {
            // Update Arrows
            arrowA.position.copy(state.origin);
            const lengthA = state.vectorA.length();
            if (lengthA > 0.01) {
                arrowA.setDirection(state.vectorA.clone().normalize());
                arrowA.setLength(lengthA, 0.3, 0.15);
                arrowA.visible = true;
            } else {
                arrowA.visible = false;
            }

            arrowB.position.copy(state.origin);
            const lengthB = state.vectorB.length();
             if (lengthB > 0.01) {
                arrowB.setDirection(state.vectorB.clone().normalize());
                arrowB.setLength(lengthB, 0.3, 0.15);
                arrowB.visible = true;
            } else {
                arrowB.visible = false;
            }

            // Update Draggable Spheres
            sphereA.position.copy(state.origin).add(state.vectorA);
            sphereB.position.copy(state.origin).add(state.vectorB);
            originSphere.position.copy(state.origin);
            
            // Update Angle Curve
            const angle = state.vectorA.angleTo(state.vectorB);
            const curveRadius = 0.4;
            if (angle > 0.01 && lengthA > 0.01 && lengthB > 0.01) {
                const vecA_norm = state.vectorA.clone().normalize();
                const axis = new THREE.Vector3().crossVectors(vecA_norm, state.vectorB.clone().normalize()).normalize();
                if (axis.lengthSq() > 0.1) {
                    const points = [];
                    const numSegments = 32;
                    const quaternion = new THREE.Quaternion();
                    for (let i = 0; i <= numSegments; i++) {
                        const t = i / numSegments;
                        quaternion.setFromAxisAngle(axis, angle * t);
                        const point = vecA_norm.clone().applyQuaternion(quaternion).multiplyScalar(curveRadius).add(state.origin);
                        points.push(point);
                    }
                    angleCurve.geometry.setFromPoints(points);
                    angleCurve.visible = true;
                } else {
                    angleCurve.visible = false;
                }
            } else {
                angleCurve.visible = false;
            }
        }

        /**
         * Updates the DOM elements (inputs and displays) with values from the state.
         */
        function updateUI() {
            // Update input fields if they don't have focus
            if(document.activeElement !== vecAx_input) vecAx_input.value = state.vectorA.x.toFixed(2);
            if(document.activeElement !== vecAy_input) vecAy_input.value = state.vectorA.y.toFixed(2);
            if(document.activeElement !== vecAz_input) vecAz_input.value = state.vectorA.z.toFixed(2);
            if(document.activeElement !== vecBx_input) vecBx_input.value = state.vectorB.x.toFixed(2);
            if(document.activeElement !== vecBy_input) vecBy_input.value = state.vectorB.y.toFixed(2);
            if(document.activeElement !== vecBz_input) vecBz_input.value = state.vectorB.z.toFixed(2);
            
            // Update display elements
            angleDisplay.textContent = `${state.angleDegrees.toFixed(2)}°`;
            cosineSimDisplay.textContent = state.cosineSimilarity.toFixed(4);
            vecACoordsDisplay.textContent = `A: (${state.vectorA.x.toFixed(2)}, ${state.vectorA.y.toFixed(2)}, ${state.vectorA.z.toFixed(2)})`;
            vecBCoordsDisplay.textContent = `B: (${state.vectorB.x.toFixed(2)}, ${state.vectorB.y.toFixed(2)}, ${state.vectorB.z.toFixed(2)})`;
        }
        
        /**
         * Calculates angle and cosine similarity and stores them in the state.
         */
        function calculateMetrics() {
            const magnitudeA = state.vectorA.length();
            const magnitudeB = state.vectorB.length();

            if (magnitudeA === 0 || magnitudeB === 0) {
                state.angleDegrees = 0;
                state.cosineSimilarity = 0;
                return;
            }

            const cosSim = state.vectorA.dot(state.vectorB) / (magnitudeA * magnitudeB);
            state.cosineSimilarity = cosSim;

            const angleRad = Math.acos(Math.min(1, Math.max(-1, cosSim)));
            state.angleDegrees = THREE.MathUtils.radToDeg(angleRad);
        }

        // --- Event Listener Setup ---

        /**
         * Sets up event listeners for DOM elements and window events.
         */
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            });

            // Input field changes
            const inputs = [vecAx_input, vecAy_input, vecAz_input, vecBx_input, vecBy_input, vecBz_input];
            inputs.forEach(input => {
                input.addEventListener('input', () => {
                    state.vectorA.set(parseFloat(vecAx_input.value) || 0, parseFloat(vecAy_input.value) || 0, parseFloat(vecAz_input.value) || 0);
                    state.vectorB.set(parseFloat(vecBx_input.value) || 0, parseFloat(vecBy_input.value) || 0, parseFloat(vecBz_input.value) || 0);
                    updateAll();
                });
            });
        }
        
        /**
         * Configures the DragControls event listeners.
         */
        function setupDragControls() {
            dragControls.addEventListener('dragstart', (event) => {
                orbitControls.enabled = false;
                event.object.material = event.object.userData.hoverMaterial;
            });

            dragControls.addEventListener('drag', (event) => {
                const newPos = event.object.position;
                if (event.object.userData.vectorType === 'Origin') {
                    // If origin is dragged, update its position
                    state.origin.copy(newPos);
                } else {
                    // If a vector endpoint is dragged, update the vector relative to the origin
                    const newVector = newPos.clone().sub(state.origin);
                    if (event.object.userData.vectorType === 'A') {
                        state.vectorA.copy(newVector);
                    } else if (event.object.userData.vectorType === 'B') {
                        state.vectorB.copy(newVector);
                    }
                }
                updateAll();
            });

            dragControls.addEventListener('dragend', (event) => {
                orbitControls.enabled = true;
                event.object.material = event.object.userData.material;
            });
            
            dragControls.addEventListener('hoveron', (event) => {
                if(dragControls.object) return; // don't show hover if an object is being dragged
                event.object.material = event.object.userData.hoverMaterial;
            });
            
            dragControls.addEventListener('hoveroff', (event) => {
                event.object.material = event.object.userData.material;
            });
        }

        // --- Start the application ---
        init();

    </script>
</body>
</html>
