<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Gradient Descent</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --accent-color: #2f8d46;
            --ui-color: #cccccc;
            --bg-color: #ffffff;
            --text-color: #000000;
            --light-gray: #f0f0f0;
            --info-color: #2196F3;
        }

        body {
            font-family: 'Inter', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #app-container {
            width: 100%;
            max-width: 900px;
            display: grid;
            /* Default grid areas for smaller screens (single column layout) */
            grid-template-columns: 1fr;
            /* Explicit row heights: auto for buttons/hyper-params, 1fr for scatter (takes available space) */
            grid-template-rows: auto 1fr auto auto; 
            gap: 16px;
            grid-template-areas:
                "action-buttons"
                "scatter-plot"
                "hyper-params"
                "feedback-area"; 
            padding: 16px;
            box-sizing: border-box;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        @media (min-width: 768px) {
            #app-container {
                grid-template-columns: 1fr; /* Simpler one column for large screen */
                grid-template-rows: auto 1fr auto auto; /* Kept the same grid rows for consistency */
                grid-template-areas:
                    "action-buttons"
                    "scatter-plot"
                    "hyper-params"
                    "feedback-area";
            }
        }

        #scatter-canvas-container {
            grid-area: scatter-plot;
            position: relative; /* Essential for positioning overlay */
            display: flex;
            flex-direction: column;
            border: 1px solid var(--ui-color);
            border-radius: 6px;
            overflow: hidden;
            background-color: var(--light-gray);
            height: 450px; /* Slightly adjusted height to prevent clipping on smaller screens */
        }
        
        #loss-canvas-container { /* Now positioned absolutely within scatter-canvas-container */
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 25%; /* Reduced width to 25% */
            height: 30%; /* Kept height at 30% */
            display: flex;
            flex-direction: column;
            border: 1px solid var(--ui-color);
            border-radius: 6px;
            overflow: hidden;
            background-color: rgba(240, 240, 240, 0.5); /* 50% transparent background */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 5; /* Ensure it's above the main canvas but below toggle */
            padding: 5px; /* Internal padding */
        }

        #loss-canvas-container .canvas-title {
            margin: 2px 0; /* Smaller margin for title */
            font-size: 10px; /* Smaller font for title */
        }
        #loss-canvas-container canvas {
            height: calc(100% - 18px); /* Adjust canvas height for smaller title */
        }


        .canvas-title {
            text-align: center;
            font-size: 14px;
            margin: 8px 0;
            color: #555;
            font-weight: bold;
        }

        canvas {
            width: 100%;
            height: calc(100% - 32px); /* Adjust height for title */
            display: block;
            background-color: var(--light-gray);
        }

        #action-buttons-container {
            grid-area: action-buttons;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            background-color: var(--light-gray);
        }
        
        #hyper-params-container {
            grid-area: hyper-params;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            background-color: var(--light-gray);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            border: 1px solid var(--ui-color);
            border-radius: 6px;
            background-color: var(--bg-color);
        }

        button {
            font-family: 'Inter', monospace;
            font-size: 14px;
            padding: 10px;
            border: 1px solid var(--ui-color);
            background-color: var(--bg-color);
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        button:hover {
            background-color: var(--light-gray);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        button.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        label {
            font-size: 13px;
            text-align: center;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 5px; /* Reduced height */
            background: var(--light-gray);
            outline: none;
            border-radius: 4px;
            border: 1px solid var(--ui-color);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px; /* Reduced size */
            height: 14px; /* Reduced size */
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px; /* Reduced size */
            height: 14px; /* Reduced size */
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
        }

        #feedback-container {
            grid-area: feedback-area;
            background-color: var(--light-gray);
            padding: 12px;
            border: 1px solid var(--ui-color);
            font-size: 14px;
            line-height: 1.5;
            min-height: 60px;
            box-sizing: border-box;
            text-align: center;
            border-radius: 6px;
            color: #333;
        }

        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            cursor: help;
        }

        .tooltip-container .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position above the element */
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
        }

        .tooltip-container .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }

        .tooltip-container:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* True Line Toggle Button on Canvas */
        #true-line-toggle-on-canvas {
            position: absolute;
            top: 10px; /* Adjust as needed */
            right: 10px; /* Adjust as needed */
            z-index: 10; /* Ensure it's above the canvas */
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent background */
            padding: 8px 12px;
            border-radius: 20px; /* Pill shape */
            border: 1px solid var(--ui-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }

        #true-line-toggle-on-canvas:hover {
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        #true-line-toggle-on-canvas label {
            margin: 0; /* Override default label margin */
            font-size: 13px;
            color: #333;
            cursor: pointer;
            user-select: none; /* Prevent text selection on double click */
        }

        #true-line-toggle-on-canvas input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid var(--ui-color);
            border-radius: 3px;
            margin-right: 8px;
            cursor: pointer;
            position: relative;
            outline: none;
        }

        #true-line-toggle-on-canvas input[type="checkbox"]:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        #true-line-toggle-on-canvas input[type="checkbox"]:checked::after {
            content: '\2713'; /* Checkmark character */
            color: white;
            font-size: 12px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            line-height: 1;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <!-- Top Action Buttons -->
        <div id="action-buttons-container">
            <button id="reset-btn"><i class="fas fa-sync-alt"></i> Reset</button>
            <button id="randomize-btn"><i class="fas fa-random"></i> Randomize Data</button>
            <button id="next-step-btn"><i class="fas fa-forward"></i> Next Step</button>
            <button id="auto-run-btn"><i class="fas fa-play"></i> Auto-Run</button>
        </div>

        <!-- Main Scatter Plot Canvas -->
        <div id="scatter-canvas-container">
            <div class="canvas-title">
                Model Fit (y = mx + b)
                <span class="tooltip-container">
                    <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                    <span class="tooltiptext">
                        This plot shows your data points and the line currently fitted by the model. 
                        Click to add new points, or drag existing ones to see how the model adapts!
                    </span>
                </span>
            </div>
            <canvas id="scatter-canvas"></canvas>

            <!-- True Line Toggle Button over Canvas -->
            <div id="true-line-toggle-on-canvas">
                <input type="checkbox" id="true-line-checkbox">
                <label for="true-line-checkbox">
                    Show True Line
                    <span class="tooltip-container">
                        <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                        <span class="tooltiptext">
                            Toggle to see the 'ideal' line that generated the data (without noise). See how close your model gets!
                        </span>
                    </span>
                </label>
            </div>

            <!-- Loss Plot Canvas (now as an overlay) -->
            <div id="loss-canvas-container">
                <div class="canvas-title">
                    Loss (Mean Squared Error)
                    <span class="tooltip-container">
                        <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                        <span class="tooltiptext">
                            The Loss measures how "wrong" your model is. Gradient Descent tries to minimize this value. 
                            A lower loss means a better fit.
                        </span>
                    </span>
                </div>
                <canvas id="loss-canvas"></canvas>
            </div>
        </div>
        
        <!-- Hyper-parameters Controls -->
        <div id="hyper-params-container">
            <div class="control-group">
                <label id="lr-label" for="lr-slider">
                    Learning Rate: 0.001
                    <span class="tooltip-container">
                        <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                        <span class="tooltiptext">
                            How big a step the model takes with each update. Too high, and it might overshoot; too low, and it learns slowly.
                        </span>
                    </span>
                </label>
                <input type="range" id="lr-slider" min="0.0001" max="0.1" step="0.0001" value="0.001">
            </div>

            <div class="control-group">
                <label id="num-points-label" for="num-points-slider">
                    Num Points: 100
                    <span class="tooltip-container">
                        <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                        <span class="tooltiptext">
                            Control how many data points are randomly generated. More points can make the model more robust.
                        </span>
                    </span>
                </label>
                <input type="range" id="num-points-slider" min="10" max="200" step="10" value="100">
            </div>

            <div class="control-group">
                <label id="noise-level-label" for="noise-level-slider">
                    Noise Level: 0.10
                    <span class="tooltip-container">
                        <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                        <span class="tooltiptext">
                            Amount of randomness in data points. Higher noise makes it harder for the line to fit perfectly.
                        </span>
                    </span>
                </label>
                <input type="range" id="noise-level-slider" min="0.0" max="0.5" step="0.01" value="0.10">
            </div>

            <div class="control-group">
                <label id="max-epochs-label" for="max-epochs-slider">
                    Max Epochs: 1000
                    <span class="tooltip-container">
                        <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                        <span class="tooltiptext">
                            Set a limit for the number of training steps (epochs). Auto-run will stop once this limit is reached.
                        </span>
                    </span>
                </label>
                <input type="range" id="max-epochs-slider" min="1" max="10000" step="1" value="1000">
            </div>
        </div>

        <!-- Feedback Container -->
        <div id="feedback-container">
            Click 'Randomize Data' to begin. Then use 'Next Step' or 'Auto-Run' to train the model.
        </div>
    </div>

    <script>
        // Get canvas elements and their 2D rendering contexts
        const scatterCanvas = document.getElementById('scatter-canvas');
        const lossCanvas = document.getElementById('loss-canvas');
        const sCtx = scatterCanvas.getContext('2d');
        const lCtx = lossCanvas.getContext('2d');

        // Get UI elements (buttons, sliders, labels, feedback area)
        const resetButton = document.getElementById('reset-btn');
        const randomizeButton = document.getElementById('randomize-btn');
        const nextStepButton = document.getElementById('next-step-btn');
        const autoRunButton = document.getElementById('auto-run-btn');
        const lrSlider = document.getElementById('lr-slider');
        const lrLabel = document.getElementById('lr-label');
        const numPointsSlider = document.getElementById('num-points-slider');
        const numPointsLabel = document.getElementById('num-points-label');
        const noiseLevelSlider = document.getElementById('noise-level-slider');
        const noiseLevelLabel = document.getElementById('noise-level-label');
        const maxEpochsSlider = document.getElementById('max-epochs-slider');
        const maxEpochsLabel = document.getElementById('max-epochs-label');
        const trueLineCheckbox = document.getElementById('true-line-checkbox');
        const feedbackContainer = document.getElementById('feedback-container');

        // Model parameters and state variables
        let points = [];        // Array to store data points {x, y}
        let m = 0.0;            // Initial slope of the regression line (set to 0 for x-axis alignment)
        let b = 0.0;            // Initial y-intercept of the regression line (set to 0 for x-axis alignment)
        let learningRate = 0.001; // How much the model parameters change per step (default 0.001)
        let lossHistory = [];   // Stores Mean Squared Error over epochs
        let epoch = 0;          // Current training iteration
        let isAutoRunning = false; // Flag for auto-run mode
        let animationFrameId;   // To control requestAnimationFrame for auto-run

        // Variables for enhanced interaction and data generation
        let trueM, trueB;       // Parameters of the 'true' line that generates the data
        let noiseLevel = 0.10;  // Amount of random noise in generated data (updated to 0.10)
        let numPoints = 100;    // Number of data points to generate (updated to 100)
        let showTrueLine = false; // Flag to toggle visibility of the true line
        let maxEpochs = 1000;     // New: Maximum number of epochs for training (default 1000)

        // Variables for drag-and-drop functionality for data points
        let draggedPoint = null; // Stores the point being dragged
        let dragOffsetX = 0;     // Mouse X offset from point center
        let dragOffsetY = 0;     // Mouse Y offset from point center

        // Constants for axis padding within the scatter plot canvas
        const PADDING_X = 40; // Pixels from left/right edges for plot area
        const PADDING_Y = 30; // Pixels from top/bottom edges for plot area

        // Constants for axis padding within the loss plot canvas
        const PADDING_X_LOSS = 20; // Pixels from left/right edges for loss plot area
        const PADDING_Y_LOSS = 15; // Pixels from top/bottom edges for loss plot area


        /**
         * Sets the canvas dimensions based on its CSS size and device pixel ratio.
         * This ensures crisp drawing on high-DPI screens.
         * @param {HTMLCanvasElement} canvas - The canvas element to size.
         */
        function setCanvasSize(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr); // Scale context to match CSS size
        }

        /**
         * Maps a normalized point (x,y from 0 to 1, representing data space)
         * to canvas coordinates (pixel space) within the padded plot area.
         * The y-axis is inverted in canvas (0 at top, height at bottom) compared
         * to typical mathematical plot conventions.
         * @param {{x: number, y: number}} val - The normalized point in data space.
         * @param {HTMLCanvasElement} canvas - The canvas element.
         * @param {number} [padX=PADDING_X] - Horizontal padding for the canvas.
         * @param {number} [padY=PADDING_Y] - Vertical padding for the canvas.
         * @returns {{x: number, y: number}} - Corresponding coordinates on the canvas.
         */
        function mapToCanvas(val, canvas, padX = PADDING_X, padY = PADDING_Y) {
            const { width, height } = canvas.getBoundingClientRect();
            const effectiveWidth = width - 2 * padX; // Width of the actual plot area
            const effectiveHeight = height - 2 * padY; // Height of the actual plot area
            return {
                x: padX + val.x * effectiveWidth, // Map x from [0,1] to [padX, width-padX]
                y: padY + (1 - val.y) * effectiveHeight // Map y from [0,1] to [height-padY, padY] (inverted)
            };
        }
        
        /**
         * Generates a new set of random data points based on a 'true' linear relationship
         * (y = trueM * x + trueB) with added random noise.
         */
        function generatePoints() {
            points = [];
            // Generate a random 'true' line for data generation
            // Wider range for trueM and trueB to make points more scattered
            trueM = Math.random() * 1.0 - 0.5; // Slope between -0.5 and 0.5
            trueB = Math.random() * 0.6 + 0.2; // Intercept between 0.2 and 0.8
            
            for (let i = 0; i < numPoints; i++) {
                const x = Math.random(); // Random x-value between 0 and 1
                const noise = (Math.random() - 0.5) * noiseLevel * 2; // Random noise based on noiseLevel, scaled
                const y = trueM * x + trueB + noise; // Calculate y with noise
                
                // Only add points that are within the [0, 1] range to keep them visible on the canvas
                if (y >= 0 && y <= 1) { // Changed to >=0 and <=1 to allow points on boundary
                    points.push({ x, y });
                }
            }
        }

        /**
         * Draws the scatter plot, including data points, the current regression line,
         * and the X-Y axes with labels and ticks. Optionally draws the 'true' line if toggled.
         */
        function drawScatterPlot() {
            const { width, height } = scatterCanvas.getBoundingClientRect();
            sCtx.clearRect(0, 0, scatterCanvas.width, scatterCanvas.height); // Clear previous drawing
            
            // Draw X and Y Axes
            sCtx.strokeStyle = '#666'; // Axis color
            sCtx.lineWidth = 1;

            // Y-axis (vertical line at PADDING_X)
            sCtx.beginPath();
            sCtx.moveTo(PADDING_X, PADDING_Y); // Top of plot area
            sCtx.lineTo(PADDING_X, height - PADDING_Y); // Bottom of plot area
            sCtx.stroke();

            // X-axis (horizontal line at height - PADDING_Y)
            sCtx.beginPath();
            sCtx.moveTo(PADDING_X, height - PADDING_Y); // Left of plot area
            sCtx.lineTo(width - PADDING_X, height - PADDING_Y); // Right of plot area
            sCtx.stroke();

            // Add labels for axes
            sCtx.fillStyle = '#333';
            sCtx.font = '12px monospace';

            // X-axis label
            sCtx.textAlign = 'center';
            sCtx.textBaseline = 'top';
            sCtx.fillText('X', width - PADDING_X / 2, height - PADDING_Y / 2);

            // Y-axis label (rotated for vertical orientation)
            sCtx.save(); // Save current context state
            // Fixed typo: Changed PITTING_Y to PADDING_Y
            sCtx.translate(PADDING_X / 2, PADDING_Y / 2 + (height - 2*PADDING_Y)/2); // Move to label position
            sCtx.rotate(-Math.PI / 2); // Rotate 90 degrees counter-clockwise
            sCtx.textAlign = 'center';
            sCtx.textBaseline = 'bottom';
            sCtx.fillText('Y', 0, 0); // Draw 'Y'
            sCtx.restore(); // Restore context to previous state (undo rotation)

            // Add tick marks and labels for X and Y axes
            // X-axis ticks (e.g., 0.0, 0.5, 1.0)
            sCtx.textBaseline = 'top'; // Align text from top of tick mark
            for (let i = 0; i <= 1; i += 0.5) {
                const xCoord = mapToCanvas({ x: i, y: 0 }, scatterCanvas).x; // Get canvas X for data X
                sCtx.beginPath();
                sCtx.moveTo(xCoord, height - PADDING_Y); // Start tick at axis
                sCtx.lineTo(xCoord, height - PADDING_Y + 5); // Extend tick downwards
                sCtx.stroke();
                sCtx.fillText(i.toFixed(1), xCoord, height - PADDING_Y + 10); // Label below tick
            }

            // Y-axis ticks (e.g., 0.0, 0.5, 1.0)
            sCtx.textAlign = 'right'; // Align text to the right of tick mark
            sCtx.textBaseline = 'middle'; // Center text vertically on tick mark
            for (let i = 0; i <= 1; i += 0.5) {
                const yCoord = mapToCanvas({ x: 0, y: i }, scatterCanvas).y; // Get canvas Y for data Y
                sCtx.beginPath();
                sCtx.moveTo(PADDING_X, yCoord); // Start tick at axis
                sCtx.lineTo(PADDING_X - 5, yCoord); // Extend tick leftwards
                sCtx.stroke();
                sCtx.fillText(i.toFixed(1), PADDING_X - 10, yCoord); // Label left of tick
            }

            // Draw data points using the new mapToCanvas
            sCtx.fillStyle = 'black';
            points.forEach(p => {
                const c = mapToCanvas(p, scatterCanvas);
                sCtx.beginPath();
                sCtx.arc(c.x, c.y, 3, 0, Math.PI * 2);
                sCtx.fill();
            });

            // Draw the current regression line (y = mx + b)
            sCtx.strokeStyle = 'blue'; /* Predicted line color set to blue */
            sCtx.lineWidth = 2;
            sCtx.beginPath();
            // Calculate start and end points of the line in canvas coordinates
            const start = mapToCanvas({ x: 0, y: m * 0 + b }, scatterCanvas);
            const end = mapToCanvas({ x: 1, y: m * 1 + b }, scatterCanvas);
            sCtx.moveTo(start.x, start.y);
            sCtx.lineTo(end.x, end.y);
            sCtx.stroke();

            // Optionally draw the 'true' line that generated the data
            if (showTrueLine) {
                sCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Lighter, semi-transparent color
                sCtx.setLineDash([5, 5]); // Dashed line style
                sCtx.beginPath();
                const trueStart = mapToCanvas({ x: 0, y: trueM * 0 + trueB }, scatterCanvas);
                const trueEnd = mapToCanvas({ x: 1, y: trueM * 1 + trueB }, scatterCanvas);
                sCtx.moveTo(trueStart.x, trueStart.y);
                sCtx.lineTo(trueEnd.x, trueEnd.y);
                sCtx.stroke();
                sCtx.setLineDash([]); // Reset line dash to solid for subsequent drawings
            }
        }

        /**
         * Draws the loss history plot, showing how Mean Squared Error changes over epochs.
         * The plot is scaled to fit the canvas and display the trend of loss reduction.
         */
        function drawLossPlot() {
            const { width, height } = lossCanvas.getBoundingClientRect();
            lCtx.clearRect(0, 0, lossCanvas.width, lossCanvas.height); // Clear previous drawing
            
            if (lossHistory.length < 2) { // Need at least two points to draw a line
                // Display a message if no loss data yet, for better user experience
                lCtx.fillStyle = '#666';
                lCtx.font = '10px monospace'; /* Smaller font for message */
                lCtx.textAlign = 'center';
                lCtx.fillText('No loss data yet.', width / 2, height / 2);
                return;
            }

            // Draw X and Y Axes for Loss Plot
            lCtx.strokeStyle = '#666'; // Axis color
            lCtx.lineWidth = 1;

            // Y-axis for Loss
            lCtx.beginPath();
            lCtx.moveTo(PADDING_X_LOSS, PADDING_Y_LOSS); // Top of plot area
            lCtx.lineTo(PADDING_X_LOSS, height - PADDING_Y_LOSS); // Bottom of plot area
            lCtx.stroke();

            // X-axis for Loss
            lCtx.beginPath();
            lCtx.moveTo(PADDING_X_LOSS, height - PADDING_Y_LOSS); // Left of plot area
            lCtx.lineTo(width - PADDING_X_LOSS, height - PADDING_Y_LOSS); // Right of plot area
            lCtx.stroke();

            // Add labels for axes (Loss Plot)
            lCtx.fillStyle = '#333';
            lCtx.font = '8px monospace';

            // X-axis label for Loss
            lCtx.textAlign = 'center';
            lCtx.textBaseline = 'top';
            lCtx.fillText('Epochs', width - PADDING_X_LOSS / 2, height - PADDING_Y_LOSS / 2);

            // Y-axis label for Loss
            lCtx.save();
            lCtx.translate(PADDING_X_LOSS / 2, PADDING_Y_LOSS / 2 + (height - 2*PADDING_Y_LOSS)/2);
            lCtx.rotate(-Math.PI / 2);
            lCtx.textAlign = 'center';
            lCtx.textBaseline = 'bottom';
            lCtx.fillText('Loss', 0, 0);
            lCtx.restore();

            // Add tick marks and labels for X and Y axes (Loss Plot)
            // X-axis ticks (e.g., 0, maxEpochs/2, maxEpochs)
            lCtx.textBaseline = 'top';
            const numXTicks = 2; // For 0, MaxEpochs/2, MaxEpochs
            for (let i = 0; i <= numXTicks; i++) {
                const epochRatio = i / numXTicks;
                const xVal = epochRatio * epoch; // Use current epoch for max value
                const xCoord = mapToCanvas({ x: epochRatio, y: 0 }, lossCanvas, PADDING_X_LOSS, PADDING_Y_LOSS).x;
                lCtx.beginPath();
                lCtx.moveTo(xCoord, height - PADDING_Y_LOSS);
                lCtx.lineTo(xCoord, height - PADDING_Y_LOSS + 3);
                lCtx.stroke();
                lCtx.fillText(xVal.toFixed(0), xCoord, height - PADDING_Y_LOSS + 5);
            }

            // Y-axis ticks (e.g., 0.0, maxLoss/2, maxLoss)
            lCtx.textAlign = 'right';
            lCtx.textBaseline = 'middle';
            const maxLossVal = Math.max(...lossHistory);
            const numYTicks = 2;
            for (let i = 0; i <= numYTicks; i++) {
                const lossRatio = i / numYTicks;
                const yVal = lossRatio * maxLossVal;
                const yCoord = mapToCanvas({ x: 0, y: lossRatio }, lossCanvas, PADDING_X_LOSS, PADDING_Y_LOSS).y;
                lCtx.beginPath();
                lCtx.moveTo(PADDING_X_LOSS, yCoord);
                lCtx.lineTo(PADDING_X_LOSS - 3, yCoord);
                lCtx.stroke();
                lCtx.fillText(yVal.toFixed(2), PADDING_X_LOSS - 5, yCoord);
            }


            lCtx.strokeStyle = 'var(--accent-color)';
            lCtx.lineWidth = 2;
            lCtx.beginPath();
            
            // Find the maximum loss to scale the plot correctly, ensuring the graph fits vertically
            const lossPlotMaxLoss = Math.max(...lossHistory);

            // Draw the loss curve by iterating through the loss history
            for (let i = 0; i < lossHistory.length; i++) {
                // X position: scaled by the index over the total history length within loss canvas padding
                const x = PADDING_X_LOSS + (i / (lossHistory.length - 1)) * (width - 2 * PADDING_X_LOSS);
                // Y position: scaled by current loss relative to max loss, then inverted within loss canvas padding
                const y = PADDING_Y_LOSS + (1 - (lossHistory[i] / lossPlotMaxLoss)) * (height - 2 * PADDING_Y_LOSS);
                if (i === 0) {
                    lCtx.moveTo(x, y); // Start path at the first point
                } else {
                    lCtx.lineTo(x, y); // Draw line to subsequent points
                }
            }
            lCtx.stroke(); // Render the line
        }

        /**
         * Calculates the Mean Squared Error (MSE) for the current regression model.
         * MSE is a common loss function for regression tasks, measuring the average
         * of the squares of the errors.
         * Formula: MSE = (1/N) * Sum((predictedY - actualY)^2)
         * @returns {number} The calculated MSE value.
         */
        function calculateLoss() {
            if (points.length === 0) return 0; // Avoid division by zero if no points
            let totalError = 0;
            for (let i = 0; i < points.length; i++) {
                const { x, y } = points[i];
                const predictedY = m * x + b; // Current model's prediction
                const error = predictedY - y; // Difference between predicted and actual
                totalError += error * error; // Square the error and sum it
            }
            return totalError / points.length; // Average the squared errors
        }

        /**
         * Performs one step of the Gradient Descent algorithm.
         * It calculates the gradients (partial derivatives of the loss function
         * with respect to m and b) and updates m and b in the direction that
         * minimizes the loss, scaled by the learning rate.
         */
        function gradientDescentStep() {
            if (points.length === 0) return; // Cannot perform step without data

            let gradM = 0; // Gradient accumulator for slope (m)
            let gradB = 0; // Gradient accumulator for y-intercept (b)
            const N = points.length; // Number of data points

            // Calculate gradients by iterating through all data points
            for (let i = 0; i < N; i++) {
                const { x, y } = points[i];
                const prediction = m * x + b; // Current prediction for the point
                // Derivatives of MSE with respect to m and b (chain rule applied)
                gradM += -2 * x * (y - prediction);
                gradB += -2 * (y - prediction);
            }

            // Update m and b using the calculated gradients and learning rate
            // The division by N averages the gradients across all points (Batch Gradient Descent)
            m -= (gradM / N) * learningRate;
            b -= (gradB / N) * learningRate;

            epoch++; // Increment the current epoch count
            lossHistory.push(calculateLoss()); // Record the loss after this update
            
            // Keep loss history to a manageable size for drawing efficiency,
            // preventing the array from growing indefinitely during auto-run
            if (lossHistory.length > 500) {
              lossHistory.shift(); // Remove the oldest loss entry
            }
        }

        /**
         * Updates the feedback message displayed to the user in the dedicated container.
         * Provides current training status, model parameters, and contextual hints
         * based on loss behavior and learning rate.
         * @param {string} [message] - An optional specific message to display (e.g., for user actions).
         */
        function updateFeedback(message = null) {
            // Get the most recent loss, or calculate it if history is empty
            const currentLoss = lossHistory.length > 0 ? lossHistory[lossHistory.length - 1] : calculateLoss();
            // Base message displaying core training metrics
            let baseMessage = `Epoch: ${epoch} | Loss (MSE): ${currentLoss.toFixed(5)} <br> Model: y = ${m.toFixed(3)}x + ${b.toFixed(3)}`;

            // Add contextual hints based on training progression and parameters
            if (lossHistory.length > 10) { // Ensure enough history for meaningful analysis
                const lastLoss = lossHistory[lossHistory.length - 2]; // Loss from the previous epoch
                
                // Check for convergence (loss stabilizing at a low value)
                if (currentLoss < lastLoss && Math.abs(currentLoss - lastLoss) < 0.00001 && epoch > 50) {
                    baseMessage += "<br> üí° Loss is stable. Model has likely converged for this learning rate.";
                } 
                // Check for divergence (loss increasing)
                else if (currentLoss > lastLoss && epoch > 5) {
                    baseMessage += "<br> ‚ö†Ô∏è Loss is increasing! Your learning rate might be too high causing divergence.";
                } 
                // Check for excellent fit (very low loss)
                else if (currentLoss < 0.0005 && epoch > 20) {
                    baseMessage += "<br> ‚ú® Excellent fit! Loss is very low. You've almost found the true line.";
                } 
                // Suggest increasing learning rate if learning is too slow
                else if (learningRate < 0.005 && currentLoss > 0.01 && epoch > 100) {
                     baseMessage += "<br> üê¢ Learning slowly. Consider increasing the learning rate for faster convergence.";
                } 
                // Warn about aggressive learning rate
                else if (learningRate > 0.1 && currentLoss > 0.1 && epoch > 10) {
                    baseMessage += "<br> üöÄ Learning rate might be too aggressive. Watch out for oscillations!";
                }
            }
            
            // Display the optional message concatenated with the base feedback
            feedbackContainer.innerHTML = message ? message + "<br>" + baseMessage : baseMessage;
        }
        
        /**
         * Performs a complete redraw of both the scatter plot and the loss plot,
         * and then updates the feedback message. This function consolidates all
         * rendering and UI updates after any model or data change.
         */
        function fullRedraw() {
            drawScatterPlot();
            drawLossPlot();
            updateFeedback();
        }
        
        /**
         * Handler for the 'Next Step' button.
         * Performs one single step of gradient descent and then redraws the UI.
         * If auto-run is active, it will be stopped to allow manual stepping.
         */
        function handleNextStep() {
            if (isAutoRunning) toggleAutoRun(); // Stop auto-run if manual step is taken
            
            // Check if max epochs are reached before taking another step
            if (epoch >= maxEpochs && maxEpochs !== Infinity) {
                updateFeedback("Maximum epochs reached. Cannot take more steps.");
                return;
            }
            gradientDescentStep(); // Perform one step of training
            fullRedraw(); // Update plots and feedback
        }

        /**
         * The animation loop function for 'Auto-Run' mode.
         * It continuously performs gradient descent steps and redraws the UI
         * until stopped or max epochs are reached.
         */
        function autoRunLoop() {
            if (!isAutoRunning) return; // Exit loop if auto-run is off

            // Stop auto-run if maximum epochs are reached
            if (epoch >= maxEpochs && maxEpochs !== Infinity) {
                toggleAutoRun(); // Stop the auto-run
                updateFeedback("Maximum epochs reached. Auto-run stopped.");
                return;
            }

            gradientDescentStep(); // Perform one step of training
            fullRedraw(); // Update plots and feedback
            animationFrameId = requestAnimationFrame(autoRunLoop); // Request next frame
        }

        /**
         * Toggles the 'Auto-Run' mode on or off.
         * Changes button text/icon and enables/disables other controls accordingly.
         */
        function toggleAutoRun() {
            isAutoRunning = !isAutoRunning; // Invert the auto-run state
            if (isAutoRunning) {
                autoRunButton.textContent = 'Stop';
                autoRunButton.classList.add('active');
                autoRunButton.innerHTML = '<i class="fas fa-stop"></i> Stop'; // Change icon to stop
                nextStepButton.disabled = true; // Disable manual step when auto-running
                autoRunLoop(); // Start the animation loop
            } else {
                autoRunButton.textContent = 'Auto-Run';
                autoRunButton.classList.remove('active');
                autoRunButton.innerHTML = '<i class="fas fa-play"></i> Auto-Run'; // Change icon to play
                nextStepButton.disabled = false; // Enable manual step when not auto-running
                cancelAnimationFrame(animationFrameId); // Stop the animation loop
            }
        }
        
        /**
         * Handler for the 'Randomize Data' button.
         * Stops auto-run if active, generates a completely new set of random data points,
         * and then redraws the entire visualization.
         */
        function handleRandomize() {
            if(isAutoRunning) toggleAutoRun(); // Stop auto-run to allow data change
            
            // Randomize trueM and trueB for the data generation
            trueM = Math.random() * 1.0 - 0.5; // Slope between -0.5 and 0.5
            trueB = Math.random() * 0.6 + 0.2; // Intercept between 0.2 and 0.8
            
            // Randomize m (slope) for the predicted line, but keep b (y-intercept) at 0.0
            m = Math.random() * 2 - 1; // Random slope between -1 and 1
            b = 0.0;                   // Always start on x-axis

            epoch = 0;         // Reset epoch count
            lossHistory = [];  // Clear loss history

            generatePoints(); // Generate new random data
            fullRedraw(); // Update plots and feedback
            updateFeedback("New random data and initial line generated. Start training!");
        }

        /**
         * Handler for the 'Reset' button.
         * Resets all model parameters (m, b), training state (epoch, loss history),
         * resets all sliders and checkboxes to their initial values, generates new data,
         * and then redraws the entire visualization.
         */
        function handleReset() {
            if (isAutoRunning) toggleAutoRun(); // Stop auto-run if active

            // Reset model parameters to fixed initial values (starting on X-axis)
            m = 0.0; 
            b = 0.0; 
            epoch = 0;         // Reset epoch count
            lossHistory = [];  // Clear loss history
            
            // Reset all control sliders and inputs to their default values as per user request
            lrSlider.value = 0.001;
            handleLearningRateChange(); // Update learning rate and label
            numPointsSlider.value = 100; // Default to 100 points
            handleNumPointsChange();
            noiseLevelSlider.value = 0.10; /* Updated default noise level */
            handleNoiseLevelChange();
            maxEpochsSlider.value = 1000; /* Updated default max epochs */
            handleMaxEpochsChange();     // Update Max Epochs and label
            trueLineCheckbox.checked = false;
            handleTrueLineToggle();

            generatePoints(); // Generate new data points based on reset settings
            fullRedraw();     // Redraw everything to reflect the reset state
            updateFeedback("State reset. New random line and data generated. Ready to train!");
        }

        /**
         * Handler for learning rate slider changes.
         * Updates the global learningRate variable and its display label.
         */
        function handleLearningRateChange() {
            learningRate = parseFloat(lrSlider.value);
            lrLabel.innerHTML = `Learning Rate: ${learningRate.toFixed(4)} 
                                <span class="tooltip-container">
                                    <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                                    <span class="tooltiptext">
                                        How big a step the model takes with each update. Too high, and it might overshoot; too low, and it learns slowly.
                                    </span>
                                </span>`;
        }

        /**
         * Handler for number of points slider changes.
         * Updates the global numPoints variable and its display label.
         * Re-generates data points with the new count and redraws.
         */
        function handleNumPointsChange() {
            numPoints = parseInt(numPointsSlider.value);
            numPointsLabel.innerHTML = `Num Points: ${numPoints}
                                <span class="tooltip-container">
                                    <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                                    <span class="tooltiptext">
                                        Control how many data points are randomly generated. More points can make the model more robust.
                                    </span>
                                </span>`;
            if(isAutoRunning) toggleAutoRun(); // Stop auto-run before changing data
            generatePoints(); // Generate new points with the updated count
            fullRedraw(); // Update plots and feedback
        }

        /**
         * Handler for noise level slider changes.
         * Updates the global noiseLevel variable and its display label.
         * Re-generates data points with the new noise level and redraws.
         */
        function handleNoiseLevelChange() {
            noiseLevel = parseFloat(noiseLevelSlider.value);
            noiseLevelLabel.innerHTML = `Noise Level: ${noiseLevel.toFixed(2)}
                                <span class="tooltip-container">
                                    <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                                    <span class="tooltiptext">
                                        Amount of randomness in data points. Higher noise makes it harder for the line to fit perfectly.
                                    </span>
                                </span>`;
            if(isAutoRunning) toggleAutoRun(); // Stop auto-run before changing data
            generatePoints(); // Generate new points with the updated noise level
            fullRedraw(); // Update plots and feedback
        }

        /**
         * Handler for max epochs slider changes.
         * Updates the global maxEpochs variable and its display label.
         */
        function handleMaxEpochsChange() {
            maxEpochs = parseInt(maxEpochsSlider.value); // Read from slider
            maxEpochsLabel.innerHTML = `Max Epochs: ${maxEpochs}
                                <span class="tooltip-container">
                                    <i class="fas fa-info-circle" style="color: var(--info-color);"></i>
                                    <span class="tooltiptext">
                                        Set a limit for the number of training steps (epochs). Auto-run will stop once this limit is reached.
                                    </span>
                                </span>`;
        }

        /**
         * Handler for 'Show True Line' checkbox toggle.
         * Updates the global showTrueLine flag and triggers a redraw to update visibility.
         */
        function handleTrueLineToggle() {
            showTrueLine = trueLineCheckbox.checked;
            fullRedraw(); // Redraw to show/hide the true line
        }

        /**
         * Mouse down event listener for the scatter canvas to handle adding new data points
         * or initiating the dragging of existing data points.
         * @param {MouseEvent} e - The mouse event.
         */
        scatterCanvas.addEventListener('mousedown', (e) => {
            const rect = scatterCanvas.getBoundingClientRect();
            // Calculate mouse coordinates relative to canvas, adjusted for DPR if necessary (handled by ctx.scale)
            const mouseX = (e.clientX - rect.left);
            const mouseY = (e.clientY - rect.top);

            // Check if clicking near an existing point for dragging
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const canvasP = mapToCanvas(p, scatterCanvas);
                // Calculate distance from mouse click to the center of the point
                const dist = Math.sqrt(Math.pow(mouseX - canvasP.x, 2) + Math.pow(mouseY - canvasP.y, 2));
                if (dist < 8) { // If click is within 8 pixels of a point (a small hit area)
                    draggedPoint = p; // Mark this point as being dragged
                    dragOffsetX = mouseX - canvasP.x; // Store offset for smooth dragging (mouse relative to point center)
                    dragOffsetY = mouseY - canvasP.y;
                    if (isAutoRunning) toggleAutoRun(); // Stop auto-run when user starts dragging
                    updateFeedback("Dragging existing data point...");
                    return; // Stop checking after finding a point to drag
                }
            }

            // If no existing point was clicked, add a new data point at the click location
            // Convert mouse coordinates back from pixel space to normalized [0,1] data space
            // Ensure the new point is within the *padded* plot area
            if (mouseX >= PADDING_X && mouseX <= (rect.width - PADDING_X) &&
                mouseY >= PADDING_Y && mouseY <= (rect.height - PADDING_Y)) {
                const x = (mouseX - PADDING_X) / (rect.width - 2 * PADDING_X);
                const y = 1 - ((mouseY - PADDING_Y) / (rect.height - 2 * PADDING_Y));
                points.push({ x, y }); // Add the new point to the dataset
                fullRedraw(); // Update plots and feedback to show the new point
                updateFeedback(`Added a new data point. Model will now try to fit it.`);
            }
        });

        /**
         * Mouse move event listener for the scatter canvas to handle updating the position
         * of a dragged data point.
         * @param {MouseEvent} e - The mouse event.
         */
        scatterCanvas.addEventListener('mousemove', (e) => {
            if (draggedPoint) { // Only if a point is currently being dragged
                const rect = scatterCanvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left);
                const mouseY = (e.clientY - rect.top);

                // Update the dragged point's position based on mouse movement and initial offset
                // Clamp coordinates to [0, 1] range relative to the padded plot area
                const newX = (mouseX - PADDING_X - dragOffsetX) / (rect.width - 2 * PADDING_X);
                const newY = 1 - ((mouseY - PADDING_Y - dragOffsetY) / (rect.height - 2 * PADDING_Y));

                draggedPoint.x = Math.max(0, Math.min(1, newX));
                draggedPoint.y = Math.max(0, Math.min(1, newY));
                
                fullRedraw(); // Redraw immediately to show the point moving
                updateFeedback("Dragging data point. Observe how the line tries to adjust!");
            }
        });

        /**
         * Mouse up event listener for the scatter canvas to stop the dragging operation.
         */
        scatterCanvas.addEventListener('mouseup', () => {
            if (draggedPoint) {
                draggedPoint = null; // Clear the dragged point reference
                updateFeedback("Data point released. Continue training!");
            }
        });

        /**
         * Mouse leave event listener for the scatter canvas to stop dragging if the mouse
         * cursor moves out of the canvas area.
         */
        scatterCanvas.addEventListener('mouseleave', () => {
            if (draggedPoint) {
                draggedPoint = null;
                updateFeedback("Mouse left canvas, stopped dragging.");
            }
        });


        /**
         * Initializes the application: sets initial canvas sizes, adds all necessary
         * event listeners to UI controls, and performs the initial setup of the app state.
         */
        function init() {
            setCanvasSize(scatterCanvas); // Set initial size for scatter plot canvas
            setCanvasSize(lossCanvas);    // Set initial size for loss plot canvas
            
            // Attach event listeners to all interactive UI elements
            resetButton.addEventListener('click', handleReset);
            randomizeButton.addEventListener('click', handleRandomize);
            nextStepButton.addEventListener('click', handleNextStep);
            autoRunButton.addEventListener('click', toggleAutoRun);
            lrSlider.addEventListener('input', handleLearningRateChange);
            numPointsSlider.addEventListener('input', handleNumPointsChange);
            noiseLevelSlider.addEventListener('input', handleNoiseLevelChange);
            maxEpochsSlider.addEventListener('input', handleMaxEpochsChange);
            trueLineCheckbox.addEventListener('change', handleTrueLineToggle);
            
            // Add a global resize listener to ensure canvases remain responsive
            window.addEventListener('resize', () => {
                setCanvasSize(scatterCanvas);
                setCanvasSize(lossCanvas);
                fullRedraw(); // Redraw everything after resize
            });

            // Perform initial setup of the application state (e.g., generate first data, reset model)
            handleReset(); 
        }

        // Start the application once the entire DOM content is fully loaded
        init();
    </script>
</body>
</html>
