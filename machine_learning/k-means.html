<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering</title>
    <style>
        :root {
            --accent-green: #2f8d46;
            --light-gray: #cccccc;
            --dark-gray: #333333;
            --bg-color: #ffffff;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            font-family: monospace;
            background-color: var(--bg-color);
            color: var(--dark-gray);
            overflow: hidden;
        }

        body {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 600px;
            width: 90%;
        }

        #canvas {
            width: 100%;
            height: 400px;
            border: 2px solid var(--light-gray);
            border-radius: 4px;
            background-color: var(--bg-color);
        }

        .controls-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        #k-slider-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: #f0f0f0;
            padding: 0.5rem 1rem;
            border-radius: 20px;
        }

        #k-value-label {
            font-weight: bold;
            min-width: 50px;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 5px;
            background: var(--light-gray);
            outline: none;
            border-radius: 5px;
            transition: opacity .2s;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--dark-gray);
            cursor: pointer;
            border-radius: 50%;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--dark-gray);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        button {
            font-family: monospace;
            font-size: 14px;
            padding: 10px 16px;
            border: 2px solid var(--light-gray);
            background-color: var(--bg-color);
            color: var(--dark-gray);
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
        }

        button:hover {
            border-color: var(--dark-gray);
        }
        
        button:active {
            background-color: var(--dark-gray);
            color: var(--bg-color);
        }

        button#auto-run-btn.running {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-color);
        }
        
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        #feedback {
            height: 20px;
            font-size: 14px;
            color: #555;
            transition: color 0.3s;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <svg id="canvas" viewBox="0 0 600 400"></svg>
        <div class="controls-row">
            <div id="k-slider-container">
                <label for="k-slider">K:</label>
                <input type="range" id="k-slider" min="2" max="8" value="3">
                <span id="k-value-label">3</span>
            </div>
            <button id="randomize-btn">Randomize</button>
            <button id="reset-btn">Reset</button>
        </div>
        <div class="controls-row">
            <button id="next-step-btn">Next Step</button>
            <button id="auto-run-btn">Auto-Run</button>
        </div>
        <p id="feedback">Adjust K or randomize points to begin.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const kSlider = document.getElementById('k-slider');
        const kValueLabel = document.getElementById('k-value-label');
        const randomizeBtn = document.getElementById('randomize-btn');
        const resetBtn = document.getElementById('reset-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const autoRunBtn = document.getElementById('auto-run-btn');
        const feedbackEl = document.getElementById('feedback');
        
        const SVG_NS = "http://www.w3.org/2000/svg";
        const WIDTH = 600;
        const HEIGHT = 400;
        const NUM_POINTS = 100;
        const PADDING = 20;

        const CLUSTER_COLORS = [
            '#e6194b', '#3cb44b', '#ffe119', '#4363d8', 
            '#f58231', '#911eb4', '#46f0f0', '#f032e6'
        ];
        const POINT_COLOR = '#888888';

        let k = 3;
        let points = [];
        let centroids = [];
        let assignments = [];
        
        let state = 'IDLE'; // IDLE, INITIALIZED, ASSIGNED, UPDATED, CONVERGED
        let iteration = 0;
        let autoRunInterval = null;

        function createSVGElement(tag, attributes) {
            const el = document.createElementNS(SVG_NS, tag);
            for (const key in attributes) {
                el.setAttribute(key, attributes[key]);
            }
            return el;
        }
        
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function generatePoints() {
            points = [];
            for (let i = 0; i < NUM_POINTS; i++) {
                points.push({
                    x: Math.random() * (WIDTH - PADDING * 2) + PADDING,
                    y: Math.random() * (HEIGHT - PADDING * 2) + PADDING
                });
            }
            resetAlgorithm();
        }

        function initializeCentroids() {
            centroids = [];
            const usedIndices = new Set();
            for (let i = 0; i < k; i++) {
                let idx;
                do {
                    idx = Math.floor(Math.random() * points.length);
                } while (usedIndices.has(idx));
                usedIndices.add(idx);
                centroids.push({ 
                    x: points[idx].x, 
                    y: points[idx].y, 
                    color: CLUSTER_COLORS[i] 
                });
            }
            assignments = new Array(points.length).fill(-1);
            iteration = 0;
            state = 'INITIALIZED';
            updateFeedback('Ready. Press "Next Step" or "Auto-Run".');
            draw();
        }

        function assignStep() {
            let changed = false;
            for (let i = 0; i < points.length; i++) {
                let min_dist = Infinity;
                let closest_centroid = -1;
                for (let j = 0; j < centroids.length; j++) {
                    const dist = distance(points[i], centroids[j]);
                    if (dist < min_dist) {
                        min_dist = dist;
                        closest_centroid = j;
                    }
                }
                if (assignments[i] !== closest_centroid) {
                    changed = true;
                }
                assignments[i] = closest_centroid;
            }
            state = 'ASSIGNED';
            iteration++;
            updateFeedback(`Iteration ${iteration}: Points assigned to centroids.`);
            draw();
            return changed;
        }

        function updateStep() {
            let centroidsMoved = false;
            const oldCentroids = JSON.parse(JSON.stringify(centroids));

            for (let i = 0; i < centroids.length; i++) {
                const clusterPoints = points.filter((_, idx) => assignments[idx] === i);
                if (clusterPoints.length > 0) {
                    const sumX = clusterPoints.reduce((acc, p) => acc + p.x, 0);
                    const sumY = clusterPoints.reduce((acc, p) => acc + p.y, 0);
                    centroids[i].x = sumX / clusterPoints.length;
                    centroids[i].y = sumY / clusterPoints.length;
                }
            }

            for(let i = 0; i < centroids.length; i++) {
                if(distance(centroids[i], oldCentroids[i]) > 0.1) {
                    centroidsMoved = true;
                    break;
                }
            }

            if (!centroidsMoved) {
                state = 'CONVERGED';
                updateFeedback(`Converged after ${iteration} iterations.`);
                if (autoRunInterval) stopAutoRun();
            } else {
                state = 'UPDATED';
                updateFeedback(`Iteration ${iteration}: Centroids updated.`);
            }
            draw();
        }

        function resetAlgorithm() {
            stopAutoRun();
            if (points.length === 0) {
                generatePoints();
            }
            initializeCentroids();
        }

        function runNextStep() {
            if (state === 'CONVERGED') return;
            if (state === 'INITIALIZED' || state === 'UPDATED') {
                assignStep();
            } else if (state === 'ASSIGNED') {
                updateStep();
            }
        }

        function toggleAutoRun() {
            if (autoRunInterval) {
                stopAutoRun();
            } else {
                startAutoRun();
            }
        }
        
        function startAutoRun() {
            autoRunBtn.textContent = 'Stop';
            autoRunBtn.classList.add('running');
            setControlsDisabled(true);
            autoRunInterval = setInterval(() => {
                if (state === 'CONVERGED') {
                    stopAutoRun();
                    return;
                }
                assignStep();
                setTimeout(() => {
                    if (state !== 'CONVERGED') {
                       updateStep();
                    }
                }, 500);
            }, 1000);
        }

        function stopAutoRun() {
            clearInterval(autoRunInterval);
            autoRunInterval = null;
            autoRunBtn.textContent = 'Auto-Run';
            autoRunBtn.classList.remove('running');
            setControlsDisabled(false);
        }

        function draw() {
            canvas.innerHTML = '';
            
            points.forEach((point, i) => {
                const color = assignments[i] === -1 ? POINT_COLOR : centroids[assignments[i]].color;
                const p = createSVGElement('circle', {
                    cx: point.x, cy: point.y, r: 4, fill: color, opacity: 0.7
                });
                canvas.appendChild(p);
            });

            centroids.forEach(centroid => {
                const c = createSVGElement('circle', {
                    cx: centroid.x, cy: centroid.y, r: 8, fill: centroid.color, 
                    stroke: 'black', 'stroke-width': 2
                });
                canvas.appendChild(c);
            });
        }
        
        function updateFeedback(text) {
            feedbackEl.textContent = text;
        }

        function setControlsDisabled(disabled) {
            randomizeBtn.disabled = disabled;
            resetBtn.disabled = disabled;
            nextStepBtn.disabled = disabled;
            kSlider.disabled = disabled;
        }
        
        kSlider.addEventListener('input', (e) => {
            k = parseInt(e.target.value);
            kValueLabel.textContent = k;
        });

        kSlider.addEventListener('change', () => {
             resetAlgorithm();
        });

        randomizeBtn.addEventListener('click', generatePoints);
        resetBtn.addEventListener('click', resetAlgorithm);
        nextStepBtn.addEventListener('click', runNextStep);
        autoRunBtn.addEventListener('click', toggleAutoRun);
        
        // Initial setup
        generatePoints();

    </script>
</body>
</html>